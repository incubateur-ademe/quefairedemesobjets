import { expect } from "@playwright/test"
import { test } from "./fixtures"
import {
  openAdvancedFilters,
  searchDummyAdresse,
  searchForAuray,
  searchForAurayInIframe,
  switchToListeMode,
  switchToCarteMode,
  moveMap,
  navigateTo,
  searchAddress,
  waitForLoadingComplete,
  getIframe,
  TIMEOUT,
  clickFirstClickableActeurMarker,
  mockApiAdresse,
} from "./helpers"

test.describe("üó∫Ô∏è Filtres Avanc√©s Carte", () => {
  async function searchInCarteMode(page) {
    await mockApiAdresse(page)
    await searchForAuray(page)
  }

  test("Filtres avanc√©s s'ouvrent et se ferment en mode carte", async ({ page }) => {
    await navigateTo(page, `/carte`)
    await searchInCarteMode(page)
    await openAdvancedFilters(
      page,
      "carte-legend",
      "modal-button-carte:filtres",
      "modal-carte:filtres",
    )
  })

  test(
    "Filtres avanc√©s s'ouvrent et se ferment en mode carte en mobile",
    { tag: ["@mobile", "@regression"] },
    async ({ page }) => {
      await navigateTo(page, `/carte`)
      await searchInCarteMode(page)
      await openAdvancedFilters(
        page,
        "view-mode-nav",
        "modal-button-carte:filtres",
        "modal-carte:filtres",
      )
    },
  )
})
test.describe("üó∫Ô∏è Affichage L√©gende Carte", () => {
  test(
    "La carte affiche la l√©gende apr√®s une recherche",
    {
      tag: ["@regression"],
    },
    async ({ page }) => {
      // Navigate to the carte page
      await navigateTo(page, `/carte`)

      await expect(page.getByTestId("carte-legend")).toBeHidden()

      // Mock the address API before searching
      await mockApiAdresse(page)

      // Fill "Adresse" autocomplete input
      await searchForAuray(page)
      await expect(page.getByTestId("carte-legend")).toBeVisible()
    },
  )
})

test.describe("üó∫Ô∏è S√©lection de Pinpoints", () => {
  test(
    "Le pinpoint cliqu√© devient actif et les autres sont d√©sactiv√©s",
    { tag: ["@regression"] },
    async ({ page }) => {
      // Navigate to the preview page with multiple pinpoints
      await navigateTo(page, `/lookbook/preview/components/acteur_pinpoint_multiple`)

      const pinpoint1 = page.getByTestId("pinpoint-1").locator("a")
      const pinpoint2 = page.getByTestId("pinpoint-2").locator("a")

      // Initially, no pinpoint should have the active class
      await expect(pinpoint1).not.toHaveClass(/active-pinpoint/)
      await expect(pinpoint2).not.toHaveClass(/active-pinpoint/)

      // Click on first pinpoint
      await pinpoint1.click()
      await expect(pinpoint1).toHaveClass(/active-pinpoint/)
      await expect(pinpoint2).not.toHaveClass(/active-pinpoint/)

      // Click on second pinpoint
      await pinpoint2.click()
      await expect(pinpoint1).not.toHaveClass(/active-pinpoint/)
      await expect(pinpoint2).toHaveClass(/active-pinpoint/)

      // Click on first pinpoint again
      await pinpoint1.click()
      await expect(pinpoint1).toHaveClass(/active-pinpoint/)
      await expect(pinpoint2).not.toHaveClass(/active-pinpoint/)
    },
  )
})

test.describe("üó∫Ô∏è Basculement entre Mode Carte et Liste", () => {
  test(
    "La zone de recherche (bounding box) est pr√©serv√©e lors du changement de mode",
    { tag: ["@regression"] },
    async ({ page }) => {
      // Navigate to the test preview page that generates the iframe
      await navigateTo(page, "/lookbook/preview/tests/t_2_carte_mode_liste_switch")

      // Wait for the iframe to be loaded (generated by carte.js)
      const iframe = getIframe(page)
      await expect(iframe.locator("body")).toBeAttached({ timeout: TIMEOUT.DEFAULT })

      // Wait for the carte to be loaded - legend should be visible
      await iframe
        .locator("[data-testid='carte-legend']")
        .waitFor({ timeout: TIMEOUT.DEFAULT })

      // Helper function to get the bounding box from the URL
      async function getBoundingBoxFromURL() {
        const url = await iframe.locator("body").evaluate(() => window.location.href)
        const urlParams = new URLSearchParams(url.split("?")[1])
        return urlParams.get("bounding_box") || urlParams.get("carte_map-bounding_box")
      }

      // Get initial bounding box
      const initialBoundingBox = await getBoundingBoxFromURL()
      expect(initialBoundingBox).toBeTruthy()

      // Switch to Liste mode
      await switchToListeMode(iframe)

      // Click back to Carte mode
      await switchToCarteMode(iframe)

      // Wait for mode to switch back to Carte - legend should be visible again
      await iframe
        .locator("[data-testid='carte-legend']")
        .waitFor({ timeout: TIMEOUT.DEFAULT })

      // Check that the bounding box is still present in the URL
      const finalBoundingBox = await getBoundingBoxFromURL()
      expect(finalBoundingBox).toBeTruthy()

      // Verify that the bounding box hasn't been lost
      // Parse the JSON to compare the actual values
      const initialBbox = JSON.parse(initialBoundingBox || "{}")
      const finalBbox = JSON.parse(finalBoundingBox || "{}")
      expect(finalBbox).toEqual(initialBbox)

      // Verify that the map container is still present
      const mapContainer = iframe.locator('[data-map-target="mapContainer"]')
      await expect(mapContainer).toBeAttached()
    },
  )
})

test.describe("üó∫Ô∏è Affichage des Labels dans la Fiche Acteur", () => {
  test("Le label ESS est affich√© dans le panneau de d√©tails de l'acteur", async ({
    page,
  }) => {
    // Navigate to the test preview page with ESS filter applied
    await navigateTo(page, "/lookbook/preview/tests/t_3_ess_label_display")

    // Wait for the iframe to be loaded
    const iframe = getIframe(page)
    await expect(iframe.locator("body")).toBeAttached({ timeout: TIMEOUT.DEFAULT })

    // Wait for results to load - we should be in liste mode with ESS filtered actors
    await iframe
      .locator('span:has-text("lieux du plus proche au plus loin")')
      .waitFor({ timeout: TIMEOUT.DEFAULT })

    // Find the first "Voir la fiche" button and click it
    const voirLaFicheButton = iframe.locator('[data-testid="voir-la-fiche"]').first()
    await expect(voirLaFicheButton).toBeVisible({ timeout: TIMEOUT.SHORT })
    await voirLaFicheButton.click()

    // Wait for the acteur detail panel to load
    await iframe
      .locator("#acteurDetailsPanel [data-testid='acteur-detail-labels']")
      .waitFor({ timeout: TIMEOUT.DEFAULT })

    // Verify that the ESS label is displayed
    const acteurDetailLabels = iframe.locator(
      "#acteurDetailsPanel [data-testid='acteur-detail-labels']",
    )
    await expect(acteurDetailLabels).toContainText(
      "Enseigne de l'√©conomie sociale et solidaire",
      {
        timeout: TIMEOUT.SHORT,
      },
    )
  })
})

test.describe("üó∫Ô∏è Persistance des Filtres de L√©gende", () => {
  test("Les filtres de l√©gende restent actifs apr√®s changement de mode carte/liste", async ({
    page,
  }) => {
    // Navigate to the carte page
    await navigateTo(page, `/carte`)

    // Mock the address API before searching
    await mockApiAdresse(page)

    // Search for Auray
    await searchForAuray(page)

    // Wait for legend to be visible
    await expect(page.getByTestId("carte-legend")).toBeVisible()

    // Wait for results to be displayed (pinpoints in the addresses panel)
    await expect(
      page.locator('#addressesPanel [data-controller="pinpoint"]').first(),
    ).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Get the first filter checkbox by index (0)
    const firstFilterCheckbox = page
      .getByTestId("carte-legend")
      .locator("input[type='checkbox']")
      .nth(0)

    // Get the first checkbox group by index
    const firstCheckboxGroup = page
      .getByTestId("carte-legend")
      .locator(".fr-checkbox-group")
      .nth(0)

    // Get the icon class from the first filter's icon span
    const iconSpan = firstCheckboxGroup.locator("span[class*='fr-icon-']")

    // Wait for the icon to be visible
    await expect(iconSpan).toBeAttached()

    const iconClassAttribute = await iconSpan.getAttribute("class")

    // Extract the actual icon class (e.g., "fr-icon-recycle-line")
    const iconClasses = iconClassAttribute?.split(" ") || []
    const iconClass = iconClasses.find(
      (cls) => cls.startsWith("fr-icon-") && cls !== "fr-icon--sm",
    )

    // Verify the filter is initially checked
    await expect(firstFilterCheckbox).toBeChecked()

    // Verify markers with this icon are present in addressesPanel (using pinpoint data-controller)
    const addressesPanelIconsBefore = page.locator(
      `#addressesPanel [data-controller="pinpoint"] span.${iconClass}`,
    )
    const initialIconCount = await addressesPanelIconsBefore.count()
    expect(initialIconCount).toBeGreaterThan(0)

    // Get the label to click (since the checkbox is hidden with CSS)
    const firstCheckboxLabel = firstCheckboxGroup.locator("label")

    // Uncheck the filter by clicking on the label
    await firstCheckboxLabel.click()

    // Verify the checkbox is now unchecked
    await expect(firstFilterCheckbox).not.toBeChecked()

    // Wait for icons to be removed from addressesPanel (results are refreshed after filter change)
    const addressesPanelIconsAfter = page.locator(
      `#addressesPanel [data-controller="pinpoint"] span.${iconClass}`,
    )
    await expect(addressesPanelIconsAfter).toHaveCount(0, { timeout: TIMEOUT.DEFAULT })

    // Verify markers with this icon are no longer visible on the map
    const markersAfterUncheck = page.locator(
      `[aria-label="Map marker"] span.${iconClass}`,
    )
    expect(await markersAfterUncheck.count()).toBe(0)

    // Switch to liste mode
    await switchToListeMode(page)

    // Switch back to carte mode
    await switchToCarteMode(page)

    // Wait for results to be displayed after mode switch
    await expect(
      page.locator('#addressesPanel [data-controller="pinpoint"]').first(),
    ).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Verify the filter is still unchecked
    await expect(firstFilterCheckbox).not.toBeChecked()

    // Verify icons are still not in addressesPanel
    const addressesPanelIconsAfterSwitch = page.locator(
      `#addressesPanel [data-controller="pinpoint"] span.${iconClass}`,
    )
    expect(await addressesPanelIconsAfterSwitch.count()).toBe(0)

    // Verify markers with this icon are still not visible
    const markersAfterModeSwitch = page.locator(
      `[aria-label="Map marker"] span.${iconClass}`,
    )
    expect(await markersAfterModeSwitch.count()).toBe(0)

    // Now test that we can uncheck another filter and it still works
    // Get the second filter checkbox by index (1)
    const secondFilterCheckbox = page
      .getByTestId("carte-legend")
      .locator("input[type='checkbox']")
      .nth(1)

    // Get the second checkbox group by index
    const secondCheckboxGroup = page
      .getByTestId("carte-legend")
      .locator(".fr-checkbox-group")
      .nth(1)

    // Get the label to click (since the checkbox is hidden with CSS)
    const secondCheckboxLabel = secondCheckboxGroup.locator("label")

    // Get the icon class from the second filter's icon span
    const secondIconSpan = secondCheckboxGroup.locator("span[class*='fr-icon-']")

    const secondIconClassAttribute = await secondIconSpan.getAttribute("class")
    const secondIconClasses = secondIconClassAttribute?.split(" ") || []
    const secondIconClass = secondIconClasses.find(
      (cls) => cls.startsWith("fr-icon-") && cls !== "fr-icon--sm",
    )

    // Verify there are icons with this class before unchecking
    const secondIconsBefore = page.locator(
      `#addressesPanel [data-controller="pinpoint"] span.${secondIconClass}`,
    )
    expect(await secondIconsBefore.count()).toBeGreaterThan(0)

    // Uncheck the second filter
    await secondCheckboxLabel.click()

    // Verify the second filter is now unchecked
    await expect(secondFilterCheckbox).not.toBeChecked()

    // Wait for icons with the second icon class to be removed
    const secondIconsAfter = page.locator(
      `#addressesPanel [data-controller="pinpoint"] span.${secondIconClass}`,
    )
    await expect(secondIconsAfter).toHaveCount(0, { timeout: TIMEOUT.DEFAULT })
  })
})

test.describe("üó∫Ô∏è Bouton 'Rechercher dans cette zone'", () => {
  // TODO: Fix this test - programmatic map movement events don't trigger the button visibility
  // The mapChanged event needs to be triggered by actual map drag/zoom interactions
  // which are difficult to simulate reliably in an iframe test environment
  test("Le bouton appara√Æt apr√®s d√©placement de la carte et met √† jour les r√©sultats", async ({
    page,
  }) => {
    // Navigate to the test preview page that generates the iframe
    await navigateTo(page, "/lookbook/preview/tests/t_5_rechercher_dans_zone")

    // Wait for the iframe to be loaded (generated by carte.js)
    const iframe = getIframe(page)
    await expect(iframe.locator("body")).toBeAttached({ timeout: TIMEOUT.DEFAULT })

    // Scroll the iframe into view
    await page.locator("iframe").first().scrollIntoViewIfNeeded()

    // Search for Auray in the iframe
    await searchForAurayInIframe(iframe, undefined, page)

    // Wait for legend to be visible
    await iframe
      .locator("[data-testid='carte-legend']")
      .waitFor({ timeout: TIMEOUT.DEFAULT })

    // Wait for results to be displayed
    await expect(iframe.locator("#addressesPanel")).toBeVisible()

    // Wait for map to fully initialize and attach event listeners
    // The map waits 1s after resize stops before attaching moveend listener
    await page.waitForTimeout(2000)

    // Count initial results
    const initialResultsCount = await iframe
      .locator("#addressesPanel [data-controller='pinpoint']")
      .count()
    expect(initialResultsCount).toBeGreaterThan(0)

    // The search in zone button should be hidden initially (no bounding box yet)
    const searchInZoneButton = iframe.getByTestId("searchInZone")
    await expect(searchInZoneButton).toHaveClass(/qf-hidden/)

    // Get the bounding box input (should be empty initially)
    const bboxInput = iframe.locator('[data-search-solution-form-target="bbox"]')
    await expect(bboxInput).toBeAttached()
    const initialBoundingBox = await bboxInput.inputValue()
    expect(initialBoundingBox).toBe("") // Should be empty before map movement

    // Move the map by triggering a moveend event programmatically
    // This is more reliable than trying to simulate mouse drags in an iframe
    const mapCanvas = iframe.locator("canvas.maplibregl-canvas")
    await expect(mapCanvas).toBeVisible()

    // Trigger a moveend event on the MapLibre map instance directly.
    // This goes through the same code path as a real user drag:
    //   map.on("moveend") ‚Üí #dispatchMapChangedEvent ‚Üí controller.mapChanged ‚Üí show button
    await iframe.locator("body").evaluate(() => {
      const mapElement = document.querySelector('[data-controller*="map"]') as any
      if (!mapElement) return
      const map = mapElement.actorsMap?.map
      if (!map) return
      map.fire("moveend")
    })

    // Give time for the debounced mapChanged (300ms) to execute
    await page.waitForTimeout(500)

    // Wait for the button to appear (it will be shown after map movement is detected)
    await expect(searchInZoneButton).not.toHaveClass(/qf-hidden/, {
      timeout: TIMEOUT.LONG,
    })
    await expect(searchInZoneButton).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Click the button
    await searchInZoneButton.click()

    // Wait for loading to complete
    await waitForLoadingComplete(iframe)

    // Verify the bounding box has been set (should now have a value)
    const newBoundingBox = await bboxInput.inputValue()
    expect(newBoundingBox).toBeTruthy()
    expect(newBoundingBox).not.toBe("") // Should now be populated

    // Verify results have changed (count should be different)
    const newResultsCount = await iframe
      .locator("#addressesPanel [data-controller='pinpoint']")
      .count()
    // Results count might be different after searching in new zone
    // We just verify we still have results
    expect(newResultsCount).toBeGreaterThan(0)

    // The button should be hidden again after clicking
    await expect(searchInZoneButton).toHaveClass(/qf-hidden/)
  })
})

test.describe("üó∫Ô∏è CarteConfig Bounding Box", () => {
  test("La bounding box configur√©e dans CarteConfig est appliqu√©e au chargement initial", async ({
    page,
  }) => {
    // Navigate to the test preview page
    await navigateTo(page, "/lookbook/preview/tests/t_6_carte_config_bounding_box")

    // Wait for the iframe to be loaded (uses data-testid, not id)
    const iframe = page.frameLocator('iframe[data-testid="carte-iframe"]')
    await expect(iframe.locator("body")).toBeAttached({ timeout: TIMEOUT.DEFAULT })

    // Wait for the map to be loaded
    await expect(iframe.locator('[data-map-target="mapContainer"]')).toBeVisible({
      timeout: TIMEOUT.DEFAULT,
    })

    // Get the bounding box input value
    const bboxInput = iframe.locator('[data-map-target="bbox"]')
    await expect(bboxInput).toBeAttached()

    // Verify the bounding box has been set from CarteConfig
    const boundingBox = await bboxInput.inputValue()
    expect(boundingBox).toBeTruthy()

    // Parse the bounding box JSON
    const bbox = JSON.parse(boundingBox)

    // Verify the structure matches expected format
    expect(bbox).toHaveProperty("southWest")
    expect(bbox).toHaveProperty("northEast")
    expect(bbox.southWest).toHaveProperty("lat")
    expect(bbox.southWest).toHaveProperty("lng")
    expect(bbox.northEast).toHaveProperty("lat")
    expect(bbox.northEast).toHaveProperty("lng")

    // Verify the coordinates match the expected bounding box
    // (Auray Quiberon Terre Atlantique EPCI from the preview)
    // with some tolerance for floating point precision
    expect(bbox.southWest.lat).toBeCloseTo(47.323994, 5)
    expect(bbox.southWest.lng).toBeCloseTo(-3.210132, 5)
    expect(bbox.northEast.lat).toBeCloseTo(47.866059, 5)
    expect(bbox.northEast.lng).toBeCloseTo(-2.834623, 5)
  })
})

test.describe("üó∫Ô∏è Mini Carte - Affichage des Pinpoints", () => {
  test("La mini carte du lookbook affiche le pinpoint acteur et le pinpoint home", async ({
    page,
  }) => {
    // Navigate to the mini_carte lookbook preview
    await navigateTo(page, "/lookbook/preview/components/mini_carte")

    // Wait for the map container to be visible
    const mapContainer = page.locator('[data-map-target="mapContainer"]')
    await expect(mapContainer).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Verify the acteur pinpoint is visible (has data-controller="pinpoint" and is not the home marker)
    const acteurPinpoint = page.locator(
      '.maplibregl-marker[data-controller="pinpoint"]:not(#pinpoint-home)',
    )
    await expect(acteurPinpoint.first()).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Verify the home pinpoint is visible
    const homePinpoint = page.locator("#pinpoint-home")
    await expect(homePinpoint).toBeVisible({ timeout: TIMEOUT.DEFAULT })
  })

  test("La fiche acteur affiche une mini carte avec les pinpoints acteur et home", async ({
    page,
  }) => {
    test.slow()
    // Navigate to the carte page
    await navigateTo(page, "/carte")

    // Mock the address API before searching
    await mockApiAdresse(page)

    // Search for Auray
    await searchForAuray(page)

    // Wait for results to be displayed (pinpoints in the addresses panel)
    await expect(
      page.locator('#addressesPanel [data-controller="pinpoint"]').first(),
    ).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Switch to liste mode to access "Voir la fiche" links
    await switchToListeMode(page)

    // Wait for liste mode to be fully loaded
    const voirLaFicheButtons = page.locator('[data-testid="voir-la-fiche"]')
    await expect(voirLaFicheButtons.first()).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Click on the 5th result's "Voir la fiche" link (index 4)
    // Using the 5th result to avoid bias from acteurs whose address is just a city
    const fifthVoirLaFiche = voirLaFicheButtons.nth(4)
    await expect(fifthVoirLaFiche).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Get the href and navigate with the with_map parameter to show the mini map
    const href = await fifthVoirLaFiche.getAttribute("href")
    expect(href).toBeTruthy()

    // Navigate to the acteur page with with_map parameter to display the mini carte
    await navigateTo(page, `${href}&with_map=1`)

    // Wait for the page to load
    await expect(page.locator('[data-testid="acteur-detail-about-panel"]')).toBeVisible(
      {
        timeout: TIMEOUT.DEFAULT,
      },
    )

    // Verify the mini map container is present
    const miniMapContainer = page.locator('[data-map-target="mapContainer"]')
    await expect(miniMapContainer).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Verify the acteur pinpoint is visible on the mini map
    const acteurPinpoint = page.locator(
      '.maplibregl-marker[data-controller="pinpoint"]:not(#pinpoint-home)',
    )
    await expect(acteurPinpoint.first()).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Verify the home pinpoint is visible on the mini map
    const homePinpoint = page.locator("#pinpoint-home")
    await expect(homePinpoint).toBeVisible({ timeout: TIMEOUT.DEFAULT })
  })
})

test.describe("üó∫Ô∏è Absence du Pinpoint Home sans Adresse", () => {
  test("Le pinpoint home n'est pas visible quand seul un EPCI est d√©fini", async ({
    page,
  }) => {
    // Navigate to the test preview page with EPCI mode
    await navigateTo(page, "/lookbook/preview/tests/t_14_carte_mal_centree?mode=epci")

    // Wait for the iframe to be loaded (generated by carte.js)
    const iframe = getIframe(page)
    await expect(iframe.locator("body")).toBeAttached({ timeout: TIMEOUT.DEFAULT })

    // Wait for the map to be loaded and acteur markers to appear
    const acteurMarkers = iframe.locator(
      '.maplibregl-marker[data-controller="pinpoint"]:not(#pinpoint-home)',
    )
    await expect(acteurMarkers.first()).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Verify that the home pinpoint is NOT visible (should remain invisible without an address)
    const homePinpoint = iframe.locator("#pinpoint-home")
    await expect(homePinpoint).toHaveClass(/qf-invisible/)
  })

  test("Le pinpoint home n'est pas visible quand seule une bounding box est d√©finie", async ({
    page,
  }) => {
    // Navigate to the test preview page with bounding_box mode
    await navigateTo(
      page,
      "/lookbook/preview/tests/t_14_carte_mal_centree?mode=bounding_box",
    )

    // Wait for the iframe to be loaded (generated by carte.js)
    const iframe = getIframe(page)
    await expect(iframe.locator("body")).toBeAttached({ timeout: TIMEOUT.DEFAULT })

    // Wait for the map to be loaded and acteur markers to appear
    const acteurMarkers = iframe.locator(
      '.maplibregl-marker[data-controller="pinpoint"]:not(#pinpoint-home)',
    )
    await expect(acteurMarkers.first()).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Verify that the home pinpoint is NOT visible (should remain invisible without an address)
    const homePinpoint = iframe.locator("#pinpoint-home")
    await expect(homePinpoint).toHaveClass(/qf-invisible/)
  })
})

test.describe("üó∫Ô∏è Bouton Itin√©raire", () => {
  test("Le bouton Itin√©raire est visible sur la carte simple", async ({ page }) => {
    // Navigate directly to the carte page
    await navigateTo(page, "/carte")

    // Mock the address API before searching
    await mockApiAdresse(page)

    // Search for Auray
    await searchForAuray(page)

    // Wait for acteur markers to appear
    const acteurMarkers = page.locator(
      '.maplibregl-marker[data-controller="pinpoint"]:not(#pinpoint-home)',
    )
    await expect(acteurMarkers.first()).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Click on the first clickable acteur marker (cycles through to find one not obstructed)
    await clickFirstClickableActeurMarker(page)

    // Wait for the acteur details panel to load
    const itineraireLink = page.locator("a").filter({ hasText: "Itin√©raire" })
    await expect(itineraireLink).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Verify the itin√©raire link has the correct Google Maps URL structure
    const href = await itineraireLink.getAttribute("href")
    expect(href).toContain("https://www.google.com/maps/dir/")
    expect(href).toContain("origin=47.668099")
    expect(href).toContain("-2.990838")
  })

  test("Le bouton Itin√©raire est visible sur une carte sur mesure", async ({
    page,
  }) => {
    test.slow()
    // Navigate to the test preview page that generates a carte sur mesure iframe
    await navigateTo(
      page,
      "/lookbook/preview/tests/t_13_itineraire_button_carte_sur_mesure",
    )

    // Wait for the iframe to be loaded (generated by carte.js)
    const iframe = getIframe(page)
    await expect(iframe.locator("body")).toBeAttached({ timeout: TIMEOUT.DEFAULT })

    // Mock the address API before searching
    await mockApiAdresse(page)

    // Search for Auray in the iframe
    await searchForAurayInIframe(iframe, undefined, page)

    // Wait for acteur markers to appear (excluding the home marker which has id="pinpoint-home")
    const acteurMarkers = iframe.locator(
      '.maplibregl-marker[data-controller="pinpoint"]:not(#pinpoint-home)',
    )
    await expect(acteurMarkers.first()).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Click on the first clickable acteur marker (cycles through to find one not obstructed)
    await clickFirstClickableActeurMarker(iframe)

    // The itin√©raire link should be visible
    const itineraireLink = iframe.locator("a").filter({ hasText: "Itin√©raire" })
    await expect(itineraireLink).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Verify the itin√©raire link has the correct Google Maps URL structure
    const href = await itineraireLink.getAttribute("href")
    expect(href).toContain("https://www.google.com/maps/dir/")
    expect(href).toContain("api=1")

    // Verify origin contains the search coordinates (Auray: 47.668099, -2.990838)
    expect(href).toContain("origin=47.668099")
    expect(href).toContain("-2.990838")

    // Verify destination contains the acteur coordinates (different from origin)
    expect(href).toContain("destination=")

    // Verify travel mode is set
    expect(href).toContain("travelMode=WALKING")
  })
})
