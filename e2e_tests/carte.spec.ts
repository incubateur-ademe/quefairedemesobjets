import { expect, test } from "@playwright/test"
import {
  openAdvancedFilters,
  searchDummyAdresse,
  searchForAuray,
  searchForAurayInIframe,
  switchToListeMode,
  switchToCarteMode,
  moveMap,
  navigateTo,
  searchAddress,
  waitForLoadingComplete,
  getIframe,
  TIMEOUT,
  clickFirstClickableActeurMarker,
} from "./helpers"

test.describe("üó∫Ô∏è Filtres Avanc√©s Carte", () => {
  async function searchInCarteMode(page) {
    await searchAddress(page, "Paris", "carte", { optionIndex: 1 })
  }

  test("Filtres avanc√©s s'ouvrent et se ferment en mode carte", async ({ page }) => {
    await navigateTo(page, `/carte`)
    await searchInCarteMode(page)
    await openAdvancedFilters(
      page,
      "carte-legend",
      "modal-button-carte:filtres",
      "modal-carte:filtres",
    )
  })

  test(
    "Filtres avanc√©s s'ouvrent et se ferment en mode carte en mobile",
    { tag: ["@mobile"] },
    async ({ page }) => {
      await navigateTo(page, `/carte`)
      await searchInCarteMode(page)
      await openAdvancedFilters(
        page,
        "view-mode-nav",
        "modal-button-carte:filtres",
        "modal-carte:filtres",
      )
    },
  )
})
test.describe("üó∫Ô∏è Affichage L√©gende Carte", () => {
  test("La carte affiche la l√©gende apr√®s une recherche", async ({ page }) => {
    // Navigate to the carte page
    await navigateTo(page, `/carte`)

    await expect(page.getByTestId("carte-legend")).toBeHidden()

    // Fill "Adresse" autocomplete input
    await searchForAuray(page)
    await expect(page.getByTestId("carte-legend")).toBeVisible()
  })
})

test.describe("üó∫Ô∏è S√©lection de Pinpoints", () => {
  test("Le pinpoint cliqu√© devient actif et les autres sont d√©sactiv√©s", async ({
    page,
  }) => {
    // Navigate to the preview page with multiple pinpoints
    await navigateTo(page, `/lookbook/preview/components/acteur_pinpoint_multiple`)

    const pinpoint1 = page.getByTestId("pinpoint-1").locator("a")
    const pinpoint2 = page.getByTestId("pinpoint-2").locator("a")

    // Initially, no pinpoint should have the active class
    await expect(pinpoint1).not.toHaveClass(/active-pinpoint/)
    await expect(pinpoint2).not.toHaveClass(/active-pinpoint/)

    // Click on first pinpoint
    await pinpoint1.click()
    await expect(pinpoint1).toHaveClass(/active-pinpoint/)
    await expect(pinpoint2).not.toHaveClass(/active-pinpoint/)

    // Click on second pinpoint
    await pinpoint2.click()
    await expect(pinpoint1).not.toHaveClass(/active-pinpoint/)
    await expect(pinpoint2).toHaveClass(/active-pinpoint/)

    // Click on first pinpoint again
    await pinpoint1.click()
    await expect(pinpoint1).toHaveClass(/active-pinpoint/)
    await expect(pinpoint2).not.toHaveClass(/active-pinpoint/)
  })
})

test.describe("üó∫Ô∏è Basculement entre Mode Carte et Liste", () => {
  test("La zone de recherche (bounding box) est pr√©serv√©e lors du changement de mode", async ({
    page,
  }) => {
    // Navigate to the test preview page that generates the iframe
    await navigateTo(page, "/lookbook/preview/tests/t_2_carte_mode_liste_switch")

    // Wait for the iframe to be loaded (generated by carte.js)
    const iframe = getIframe(page)
    await expect(iframe.locator("body")).toBeAttached({ timeout: TIMEOUT.DEFAULT })

    // Wait for the carte to be loaded - legend should be visible
    await iframe
      .locator("[data-testid='carte-legend']")
      .waitFor({ timeout: TIMEOUT.DEFAULT })

    // Helper function to get the bounding box from the URL
    async function getBoundingBoxFromURL() {
      const url = await iframe.locator("body").evaluate(() => window.location.href)
      const urlParams = new URLSearchParams(url.split("?")[1])
      return urlParams.get("bounding_box") || urlParams.get("carte_map-bounding_box")
    }

    // Get initial bounding box
    const initialBoundingBox = await getBoundingBoxFromURL()
    expect(initialBoundingBox).toBeTruthy()

    // Switch to Liste mode
    await switchToListeMode(iframe)

    // Click back to Carte mode
    await switchToCarteMode(iframe)

    // Wait for mode to switch back to Carte - legend should be visible again
    await iframe
      .locator("[data-testid='carte-legend']")
      .waitFor({ timeout: TIMEOUT.DEFAULT })

    // Check that the bounding box is still present in the URL
    const finalBoundingBox = await getBoundingBoxFromURL()
    expect(finalBoundingBox).toBeTruthy()

    // Verify that the bounding box hasn't been lost
    // Parse the JSON to compare the actual values
    const initialBbox = JSON.parse(initialBoundingBox || "{}")
    const finalBbox = JSON.parse(finalBoundingBox || "{}")
    expect(finalBbox).toEqual(initialBbox)

    // Verify that the map container is still present
    const mapContainer = iframe.locator('[data-map-target="mapContainer"]')
    await expect(mapContainer).toBeAttached()
  })
})

test.describe("üó∫Ô∏è Affichage des Labels dans la Fiche Acteur", () => {
  test.skip("Le label ESS est affich√© dans le panneau de d√©tails de l'acteur", async ({
    page,
  }) => {
    // Navigate to the test preview page with ESS filter applied
    await navigateTo(page, "/lookbook/preview/tests/t_3_ess_label_display")

    // Wait for the iframe to be loaded
    const iframe = getIframe(page)
    await expect(iframe.locator("body")).toBeAttached({ timeout: TIMEOUT.DEFAULT })

    // Wait for results to load - we should be in liste mode with ESS filtered actors
    await iframe
      .locator('span:has-text("lieux du plus proche au plus loin")')
      .waitFor({ timeout: TIMEOUT.DEFAULT })

    // Find the first "Voir la fiche" button and click it
    const voirLaFicheButton = iframe.locator('[data-testid="voir-la-fiche"]').first()
    await expect(voirLaFicheButton).toBeVisible({ timeout: TIMEOUT.SHORT })
    await voirLaFicheButton.click()

    // Wait for the acteur detail panel to load
    await iframe
      .locator("#acteurDetailsPanel [data-testid='acteur-detail-labels']")
      .waitFor({ timeout: TIMEOUT.DEFAULT })

    // Verify that the ESS label is displayed
    const acteurDetailLabels = iframe.locator(
      "#acteurDetailsPanel [data-testid='acteur-detail-labels']",
    )
    await expect(acteurDetailLabels).toContainText(
      "Enseigne de l'√©conomie sociale et solidaire",
      {
        timeout: TIMEOUT.SHORT,
      },
    )
  })
})

test.describe("üó∫Ô∏è Persistance des Filtres de L√©gende", () => {
  test("Les filtres de l√©gende restent actifs apr√®s changement de mode carte/liste", async ({
    page,
  }) => {
    // Navigate to the carte page
    await navigateTo(page, `/carte`)

    // Search for Auray
    await searchForAuray(page)

    // Wait for legend to be visible
    await expect(page.getByTestId("carte-legend")).toBeVisible()

    // Wait for results to be displayed
    await expect(page.locator("#addressesPanel")).toBeVisible()

    // Get the first filter checkbox by index (0)
    const firstFilterCheckbox = page
      .getByTestId("carte-legend")
      .locator("input[type='checkbox']")
      .nth(0)

    // Get the first checkbox group by index
    const firstCheckboxGroup = page
      .getByTestId("carte-legend")
      .locator(".fr-checkbox-group")
      .nth(0)

    // Get the icon class from the first filter's icon span
    const iconSpan = firstCheckboxGroup.locator("span[class*='fr-icon-']")

    // Wait for the icon to be visible
    await expect(iconSpan).toBeAttached()

    const iconClassAttribute = await iconSpan.getAttribute("class")

    // Extract the actual icon class (e.g., "fr-icon-recycle-line")
    const iconClasses = iconClassAttribute?.split(" ") || []
    const iconClass = iconClasses.find(
      (cls) => cls.startsWith("fr-icon-") && cls !== "fr-icon--sm",
    )

    // Verify the filter is initially checked
    await expect(firstFilterCheckbox).toBeChecked()

    // Verify markers with this icon are present in addressesPanel (using pinpoint data-controller)
    const addressesPanelIconsBefore = page.locator(
      `#addressesPanel [data-controller="pinpoint"] span.${iconClass}`,
    )
    const initialIconCount = await addressesPanelIconsBefore.count()
    expect(initialIconCount).toBeGreaterThan(0)

    // Get the label to click (since the checkbox is hidden with CSS)
    const firstCheckboxLabel = firstCheckboxGroup.locator("label")

    // Uncheck the filter by clicking on the label
    await firstCheckboxLabel.click()

    // Verify the checkbox is now unchecked
    await expect(firstFilterCheckbox).not.toBeChecked()

    // Wait for the loading spinner to appear and disappear (acteurs are being refreshed)
    await waitForLoadingComplete(page)

    // Verify icons are no longer in addressesPanel
    const addressesPanelIconsAfter = page.locator(
      `#addressesPanel [data-controller="pinpoint"] span.${iconClass}`,
    )
    expect(await addressesPanelIconsAfter.count()).toBe(0)

    // Verify markers with this icon are no longer visible on the map
    const markersAfterUncheck = page.locator(
      `[aria-label="Map marker"] span.${iconClass}`,
    )
    expect(await markersAfterUncheck.count()).toBe(0)

    // Switch to liste mode
    await switchToListeMode(page)

    // Switch back to carte mode
    await switchToCarteMode(page)

    // Verify the filter is still unchecked
    await expect(firstFilterCheckbox).not.toBeChecked()

    // Verify icons are still not in addressesPanel
    const addressesPanelIconsAfterSwitch = page.locator(
      `#addressesPanel [data-controller="pinpoint"] span.${iconClass}`,
    )
    expect(await addressesPanelIconsAfterSwitch.count()).toBe(0)

    // Verify markers with this icon are still not visible
    const markersAfterModeSwitch = page.locator(
      `[aria-label="Map marker"] span.${iconClass}`,
    )
    expect(await markersAfterModeSwitch.count()).toBe(0)

    // Now test that we can uncheck another filter and it still works
    // Get the second filter checkbox by index (1)
    const secondFilterCheckbox = page
      .getByTestId("carte-legend")
      .locator("input[type='checkbox']")
      .nth(1)

    // Get the second checkbox group by index
    const secondCheckboxGroup = page
      .getByTestId("carte-legend")
      .locator(".fr-checkbox-group")
      .nth(1)

    // Get the label to click (since the checkbox is hidden with CSS)
    const secondCheckboxLabel = secondCheckboxGroup.locator("label")

    // Get the icon class from the second filter's icon span
    const secondIconSpan = secondCheckboxGroup.locator("span[class*='fr-icon-']")

    const secondIconClassAttribute = await secondIconSpan.getAttribute("class")
    const secondIconClasses = secondIconClassAttribute?.split(" ") || []
    const secondIconClass = secondIconClasses.find(
      (cls) => cls.startsWith("fr-icon-") && cls !== "fr-icon--sm",
    )

    // Verify there are icons with this class before unchecking
    const secondIconsBefore = page.locator(
      `#addressesPanel [data-controller="pinpoint"] span.${secondIconClass}`,
    )
    expect(await secondIconsBefore.count()).toBeGreaterThan(0)

    // Uncheck the second filter
    await secondCheckboxLabel.click()

    // Wait for loading
    await waitForLoadingComplete(page)

    // Verify the second filter is now unchecked
    await expect(secondFilterCheckbox).not.toBeChecked()

    // Verify icons with the second icon class are now gone
    const secondIconsAfter = page.locator(
      `#addressesPanel [data-controller="pinpoint"] span.${secondIconClass}`,
    )
    expect(await secondIconsAfter.count()).toBe(0)
  })
})

test.describe("üó∫Ô∏è Bouton 'Rechercher dans cette zone'", () => {
  test.skip("Le bouton appara√Æt apr√®s d√©placement de la carte et met √† jour les r√©sultats", async ({
    page,
  }) => {
    // SKIPPED: Map movement detection doesn't work reliably in iframe test environment.
    // The moveend event listener attachment timing and iframe cross-origin issues prevent proper testing.
    // Navigate to the test preview page that generates the iframe
    await navigateTo(page, "/lookbook/preview/tests/t_5_rechercher_dans_zone")

    // Wait for the iframe to be loaded (generated by carte.js)
    const iframe = getIframe(page)
    await expect(iframe.locator("body")).toBeAttached({ timeout: TIMEOUT.DEFAULT })

    // Scroll the iframe into view
    await page.locator("iframe").first().scrollIntoViewIfNeeded()

    // Search for Auray in the iframe
    await searchForAurayInIframe(iframe)

    // Wait for legend to be visible
    await iframe
      .locator("[data-testid='carte-legend']")
      .waitFor({ timeout: TIMEOUT.DEFAULT })

    // Wait for results to be displayed
    await expect(iframe.locator("#addressesPanel")).toBeVisible()

    // Wait for map to fully initialize and attach event listeners
    // The map waits 1s after resize stops before attaching moveend listener
    await page.waitForTimeout(2000)

    // Count initial results
    const initialResultsCount = await iframe
      .locator("#addressesPanel [data-controller='pinpoint']")
      .count()
    expect(initialResultsCount).toBeGreaterThan(0)

    // The search in zone button should be hidden initially (no bounding box yet)
    const searchInZoneButton = iframe.getByTestId("searchInZone")
    await expect(searchInZoneButton).toHaveClass(/qf-hidden/)

    // Get the bounding box input (should be empty initially)
    const bboxInput = iframe.locator('[data-search-solution-form-target="bbox"]')
    await expect(bboxInput).toBeAttached()
    const initialBoundingBox = await bboxInput.inputValue()
    expect(initialBoundingBox).toBe("") // Should be empty before map movement

    // Move the map by triggering a moveend event programmatically
    // This is more reliable than trying to simulate mouse drags in an iframe
    const mapCanvas = iframe.locator("canvas.maplibregl-canvas")
    await expect(mapCanvas).toBeVisible()

    // Trigger map change event directly by calling the controller's mapChanged method
    await iframe.locator("body").evaluate(() => {
      const mapElement = document.querySelector('[data-controller*="map"]') as any
      if (!mapElement) return

      // Get current map bounds to create event detail
      const map = mapElement.actorsMap?.map
      if (!map) return

      const bounds = map.getBounds()
      const detail = {
        center: bounds.getCenter(),
        southWest: bounds.getSouthWest(),
        northEast: bounds.getNorthEast(),
      }

      // Create and dispatch the custom event that triggers mapChanged
      const event = new CustomEvent("maplibre:mapChanged", {
        detail,
        bubbles: true,
      })

      // Call mapChanged directly on the controller
      if (mapElement.mapChanged) {
        mapElement.mapChanged(event)
      }
    })

    // Give time for the debounced mapChanged function (300ms) to execute
    await page.waitForTimeout(1000)

    // Wait for the button to appear (it will be shown after map movement is detected)
    await expect(searchInZoneButton).not.toHaveClass(/qf-hidden/, {
      timeout: TIMEOUT.LONG,
    })
    await expect(searchInZoneButton).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Click the button
    await searchInZoneButton.click()

    // Wait for loading to complete
    await waitForLoadingComplete(iframe)

    // Verify the bounding box has been set (should now have a value)
    const newBoundingBox = await bboxInput.inputValue()
    expect(newBoundingBox).toBeTruthy()
    expect(newBoundingBox).not.toBe("") // Should now be populated

    // Verify results have changed (count should be different)
    const newResultsCount = await iframe
      .locator("#addressesPanel [data-controller='pinpoint']")
      .count()
    // Results count might be different after searching in new zone
    // We just verify we still have results
    expect(newResultsCount).toBeGreaterThan(0)

    // The button should be hidden again after clicking
    await expect(searchInZoneButton).toHaveClass(/qf-hidden/)
  })
})

test.describe("üó∫Ô∏è CarteConfig Bounding Box", () => {
  test.skip("La bounding box configur√©e dans CarteConfig est appliqu√©e au chargement initial", async ({
    page,
  }) => {
    // Navigate to the test preview page
    await navigateTo(page, "/lookbook/preview/tests/t_6_carte_config_bounding_box")

    // Wait for the iframe to be loaded
    const iframe = getIframe(page, "carte-iframe")
    await expect(iframe.locator("body")).toBeAttached({ timeout: TIMEOUT.DEFAULT })

    // Wait for the map to be loaded
    await expect(iframe.locator('[data-map-target="mapContainer"]')).toBeVisible({
      timeout: TIMEOUT.DEFAULT,
    })

    // Get the bounding box input value
    const bboxInput = iframe.locator('[data-map-target="bbox"]')
    await expect(bboxInput).toBeAttached()

    // Verify the bounding box has been set from CarteConfig
    const boundingBox = await bboxInput.inputValue()
    expect(boundingBox).toBeTruthy()

    // Parse the bounding box JSON
    const bbox = JSON.parse(boundingBox)

    // Verify the structure matches expected format
    expect(bbox).toHaveProperty("southWest")
    expect(bbox).toHaveProperty("northEast")
    expect(bbox.southWest).toHaveProperty("lat")
    expect(bbox.southWest).toHaveProperty("lng")
    expect(bbox.northEast).toHaveProperty("lat")
    expect(bbox.northEast).toHaveProperty("lng")

    // Verify the coordinates match the expected Angers bounding box
    // with some tolerance for floating point precision
    expect(bbox.southWest.lat).toBeCloseTo(47.457526, 5)
    expect(bbox.southWest.lng).toBeCloseTo(-0.609453, 5)
    expect(bbox.northEast.lat).toBeCloseTo(47.489048, 5)
    expect(bbox.northEast.lng).toBeCloseTo(-0.51571, 5)
  })
})

test.describe("üó∫Ô∏è Bouton Itin√©raire", () => {
  test("Le bouton Itin√©raire est visible sur la carte simple", async ({ page }) => {
    // Navigate directly to the carte page
    await navigateTo(page, "/carte")

    // Search for Auray
    await searchForAuray(page)

    // Wait for acteur markers to appear
    const acteurMarkers = page.locator(
      '.maplibregl-marker[data-controller="pinpoint"]:not(#pinpoint-home)',
    )
    await expect(acteurMarkers.first()).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Click on the first clickable acteur marker (cycles through to find one not obstructed)
    await clickFirstClickableActeurMarker(page)

    // Wait for the acteur details panel to load
    const itineraireLink = page.locator("a").filter({ hasText: "Itin√©raire" })
    await expect(itineraireLink).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Verify the itin√©raire link has the correct Google Maps URL structure
    const href = await itineraireLink.getAttribute("href")
    expect(href).toContain("https://www.google.com/maps/dir/")
    expect(href).toContain("origin=47.668099")
    expect(href).toContain("-2.990838")
  })

  test("Le bouton Itin√©raire est visible sur une carte sur mesure", async ({
    page,
  }) => {
    // Navigate to the test preview page that generates a carte sur mesure iframe
    await navigateTo(
      page,
      "/lookbook/preview/tests/t_13_itineraire_button_carte_sur_mesure",
    )

    // Wait for the iframe to be loaded (generated by carte.js)
    const iframe = getIframe(page)
    await expect(iframe.locator("body")).toBeAttached({ timeout: TIMEOUT.DEFAULT })

    // Search for Auray in the iframe
    await searchForAurayInIframe(iframe)

    // Wait for acteur markers to appear (excluding the home marker which has id="pinpoint-home")
    const acteurMarkers = iframe.locator(
      '.maplibregl-marker[data-controller="pinpoint"]:not(#pinpoint-home)',
    )
    await expect(acteurMarkers.first()).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Click on the first acteur marker
    await acteurMarkers.first().click({ force: true })

    // Wait for the acteur details panel to load via turbo-frame
    // The itin√©raire link should be visible
    const itineraireLink = iframe.locator("a").filter({ hasText: "Itin√©raire" })
    await expect(itineraireLink).toBeVisible({ timeout: TIMEOUT.DEFAULT })

    // Verify the itin√©raire link has the correct Google Maps URL structure
    const href = await itineraireLink.getAttribute("href")
    expect(href).toContain("https://www.google.com/maps/dir/")
    expect(href).toContain("api=1")

    // Verify origin contains the search coordinates (Auray: 47.668099, -2.990838)
    expect(href).toContain("origin=47.668099")
    expect(href).toContain("-2.990838")

    // Verify destination contains the acteur coordinates (different from origin)
    expect(href).toContain("destination=")

    // Verify travel mode is set
    expect(href).toContain("travelMode=WALKING")
  })
})
