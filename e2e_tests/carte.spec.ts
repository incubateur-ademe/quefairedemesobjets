import { expect, test } from "@playwright/test"
import {
  openAdvancedFilters,
  searchDummyAdresse,
  searchForAuray,
  searchForAurayInIframe,
  switchToListeMode,
  switchToCarteMode,
  moveMap,
} from "./helpers"

test.describe("ðŸ—ºï¸ Filtres AvancÃ©s Carte", () => {
  async function searchInCarteMode(page) {
    const adresseInput = page.locator('[data-testid="carte-adresse-input"]')
    await adresseInput.click()
    await adresseInput.fill("Paris")
    const autocompleteOption = page
      .locator(
        ".autocomplete-items div[data-action*='address-autocomplete#selectOption']",
      )
      .nth(1) // Select second option (index 1)
    await expect(autocompleteOption).toBeVisible({ timeout: 10000 })
    await autocompleteOption.click()
  }

  test("Filtres avancÃ©s s'ouvrent et se ferment en mode carte", async ({ page }) => {
    await page.goto(`/carte`, {
      waitUntil: "domcontentloaded",
    })
    await searchInCarteMode(page)
    await openAdvancedFilters(
      page,
      "carte-legend",
      "modal-button-carte:filtres",
      "modal-carte:filtres",
    )
  })

  test(
    "Filtres avancÃ©s s'ouvrent et se ferment en mode carte en mobile",
    { tag: ["@mobile"] },
    async ({ page }) => {
      await page.goto(`/carte`, {
        waitUntil: "domcontentloaded",
      })
      await searchInCarteMode(page)
      await openAdvancedFilters(
        page,
        "view-mode-nav",
        "modal-button-carte:filtres",
        "modal-carte:filtres",
      )
    },
  )
})
test.describe("ðŸ—ºï¸ Affichage LÃ©gende Carte", () => {
  test("La carte affiche la lÃ©gende aprÃ¨s une recherche", async ({ page }) => {
    // Navigate to the carte page
    await page.goto(`/carte`, { waitUntil: "domcontentloaded" })

    await expect(page.getByTestId("carte-legend")).toBeHidden()

    // Fill "Adresse" autocomplete input
    await searchForAuray(page)
    await expect(page.getByTestId("carte-legend")).toBeVisible()
  })
})

test.describe("ðŸ—ºï¸ SÃ©lection de Pinpoints", () => {
  test("Le pinpoint cliquÃ© devient actif et les autres sont dÃ©sactivÃ©s", async ({
    page,
  }) => {
    // Navigate to the preview page with multiple pinpoints
    await page.goto(`/lookbook/preview/components/acteur_pinpoint_multiple`, {
      waitUntil: "domcontentloaded",
    })

    const pinpoint1 = page.getByTestId("pinpoint-1").locator("a")
    const pinpoint2 = page.getByTestId("pinpoint-2").locator("a")

    // Initially, no pinpoint should have the active class
    await expect(pinpoint1).not.toHaveClass(/active-pinpoint/)
    await expect(pinpoint2).not.toHaveClass(/active-pinpoint/)

    // Click on first pinpoint
    await pinpoint1.click()
    await expect(pinpoint1).toHaveClass(/active-pinpoint/)
    await expect(pinpoint2).not.toHaveClass(/active-pinpoint/)

    // Click on second pinpoint
    await pinpoint2.click()
    await expect(pinpoint1).not.toHaveClass(/active-pinpoint/)
    await expect(pinpoint2).toHaveClass(/active-pinpoint/)

    // Click on first pinpoint again
    await pinpoint1.click()
    await expect(pinpoint1).toHaveClass(/active-pinpoint/)
    await expect(pinpoint2).not.toHaveClass(/active-pinpoint/)
  })
})

test.describe("ðŸ—ºï¸ Basculement entre Mode Carte et Liste", () => {
  test("La zone de recherche (bounding box) est prÃ©servÃ©e lors du changement de mode", async ({
    page,
  }) => {
    // Navigate to the test preview page that generates the iframe
    await page.goto("/lookbook/preview/tests/t_2_carte_mode_liste_switch", {
      waitUntil: "domcontentloaded",
    })

    // Wait for the iframe to be loaded (generated by carte.js)
    const iframe = page.frameLocator("iframe").first()
    await expect(iframe.locator("body")).toBeAttached({ timeout: 10000 })

    // Wait for the carte to be loaded - legend should be visible
    await iframe.locator("[data-testid='carte-legend']").waitFor({ timeout: 10000 })

    // Helper function to get the bounding box from the URL
    async function getBoundingBoxFromURL() {
      const url = await iframe.locator("body").evaluate(() => window.location.href)
      const urlParams = new URLSearchParams(url.split("?")[1])
      return urlParams.get("bounding_box") || urlParams.get("carte_map-bounding_box")
    }

    // Get initial bounding box
    const initialBoundingBox = await getBoundingBoxFromURL()
    expect(initialBoundingBox).toBeTruthy()

    // Switch to Liste mode
    const listeButton = iframe
      .getByTestId("view-mode-nav")
      .getByText("Liste", { exact: true })
    await listeButton.click()

    // Wait for liste mode to be active
    await expect(iframe.locator('[data-map-target="mapContainer"]')).not.toBeVisible({
      timeout: 30000,
    })

    // Click back to Carte mode
    const carteButton = iframe
      .getByTestId("view-mode-nav")
      .getByText("Carte", { exact: true })
    await carteButton.click()

    // Wait for mode to switch back to Carte - legend should be visible again
    await iframe.locator("[data-testid='carte-legend']").waitFor({ timeout: 10000 })

    // Check that the bounding box is still present in the URL
    const finalBoundingBox = await getBoundingBoxFromURL()
    expect(finalBoundingBox).toBeTruthy()

    // Verify that the bounding box hasn't been lost
    // Parse the JSON to compare the actual values
    const initialBbox = JSON.parse(initialBoundingBox || "{}")
    const finalBbox = JSON.parse(finalBoundingBox || "{}")
    expect(finalBbox).toEqual(initialBbox)

    // Verify that the map container is still present
    const mapContainer = iframe.locator('[data-map-target="mapContainer"]')
    await expect(mapContainer).toBeAttached()
  })
})

test.describe("ðŸ—ºï¸ Affichage des Labels dans la Fiche Acteur", () => {
  test("Le label ESS est affichÃ© dans le panneau de dÃ©tails de l'acteur", async ({
    page,
  }) => {
    // Navigate to the test preview page with ESS filter applied
    await page.goto("/lookbook/preview/tests/t_3_ess_label_display", {
      waitUntil: "domcontentloaded",
    })

    // Wait for the iframe to be loaded
    const iframe = page.frameLocator("iframe").first()
    await expect(iframe.locator("body")).toBeAttached({ timeout: 10000 })

    // Wait for results to load - we should be in liste mode with ESS filtered actors
    await iframe
      .locator('span:has-text("lieux du plus proche au plus loin")')
      .waitFor({ timeout: 10000 })

    // Find the first "Voir la fiche" button and click it
    const voirLaFicheButton = iframe.locator('[data-testid="voir-la-fiche"]').first()
    await expect(voirLaFicheButton).toBeVisible({ timeout: 5000 })
    await voirLaFicheButton.click()

    // Wait for the acteur detail panel to load
    await iframe
      .locator("#acteurDetailsPanel [data-testid='acteur-detail-labels']")
      .waitFor({ timeout: 10000 })

    // Verify that the ESS label is displayed
    const acteurDetailLabels = iframe.locator(
      "#acteurDetailsPanel [data-testid='acteur-detail-labels']",
    )
    await expect(acteurDetailLabels).toContainText(
      "Enseigne de l'Ã©conomie sociale et solidaire",
      {
        timeout: 5000,
      },
    )
  })
})

test.describe("ðŸ—ºï¸ Persistance des Filtres de LÃ©gende", () => {
  test("Les filtres de lÃ©gende restent actifs aprÃ¨s changement de mode carte/liste", async ({
    page,
  }) => {
    // Navigate to the carte page
    await page.goto(`/carte`, { waitUntil: "domcontentloaded" })

    // Search for Auray
    await searchForAuray(page)

    // Wait for legend to be visible
    await expect(page.getByTestId("carte-legend")).toBeVisible()

    // Wait for results to be displayed
    await expect(page.locator("#addressesPanel")).toBeVisible()

    // Get the first filter checkbox by index (0)
    const firstFilterCheckbox = page
      .getByTestId("carte-legend")
      .locator("input[type='checkbox']")
      .nth(0)

    // Get the first checkbox group by index
    const firstCheckboxGroup = page
      .getByTestId("carte-legend")
      .locator(".fr-checkbox-group")
      .nth(0)

    // Get the icon class from the first filter's icon span
    const iconSpan = firstCheckboxGroup.locator("span[class*='fr-icon-']")

    // Wait for the icon to be visible
    await expect(iconSpan).toBeAttached()

    const iconClassAttribute = await iconSpan.getAttribute("class")

    // Extract the actual icon class (e.g., "fr-icon-recycle-line")
    const iconClasses = iconClassAttribute?.split(" ") || []
    const iconClass = iconClasses.find(
      (cls) => cls.startsWith("fr-icon-") && cls !== "fr-icon--sm",
    )

    // Verify the filter is initially checked
    await expect(firstFilterCheckbox).toBeChecked()

    // Verify markers with this icon are present in addressesPanel (using pinpoint data-controller)
    const addressesPanelIconsBefore = page.locator(
      `#addressesPanel [data-controller="pinpoint"] span.${iconClass}`,
    )
    const initialIconCount = await addressesPanelIconsBefore.count()
    expect(initialIconCount).toBeGreaterThan(0)

    // Get the label to click (since the checkbox is hidden with CSS)
    const firstCheckboxLabel = firstCheckboxGroup.locator("label")

    // Uncheck the filter by clicking on the label
    await firstCheckboxLabel.click()

    // Verify the checkbox is now unchecked
    await expect(firstFilterCheckbox).not.toBeChecked()

    // Wait for the loading spinner to appear and disappear (acteurs are being refreshed)
    await expect(page.getByTestId("loading-solutions")).toBeVisible()
    await expect(page.getByTestId("loading-solutions")).toBeHidden()

    // Verify icons are no longer in addressesPanel
    const addressesPanelIconsAfter = page.locator(
      `#addressesPanel [data-controller="pinpoint"] span.${iconClass}`,
    )
    expect(await addressesPanelIconsAfter.count()).toBe(0)

    // Verify markers with this icon are no longer visible on the map
    const markersAfterUncheck = page.locator(
      `[aria-label="Map marker"] span.${iconClass}`,
    )
    expect(await markersAfterUncheck.count()).toBe(0)

    // Switch to liste mode
    await switchToListeMode(page)

    // Switch back to carte mode
    await switchToCarteMode(page)

    // Verify the filter is still unchecked
    await expect(firstFilterCheckbox).not.toBeChecked()

    // Verify icons are still not in addressesPanel
    const addressesPanelIconsAfterSwitch = page.locator(
      `#addressesPanel [data-controller="pinpoint"] span.${iconClass}`,
    )
    expect(await addressesPanelIconsAfterSwitch.count()).toBe(0)

    // Verify markers with this icon are still not visible
    const markersAfterModeSwitch = page.locator(
      `[aria-label="Map marker"] span.${iconClass}`,
    )
    expect(await markersAfterModeSwitch.count()).toBe(0)

    // Now test that we can uncheck another filter and it still works
    // Get the second filter checkbox by index (1)
    const secondFilterCheckbox = page
      .getByTestId("carte-legend")
      .locator("input[type='checkbox']")
      .nth(1)

    // Get the second checkbox group by index
    const secondCheckboxGroup = page
      .getByTestId("carte-legend")
      .locator(".fr-checkbox-group")
      .nth(1)

    // Get the label to click (since the checkbox is hidden with CSS)
    const secondCheckboxLabel = secondCheckboxGroup.locator("label")

    // Get the icon class from the second filter's icon span
    const secondIconSpan = secondCheckboxGroup.locator("span[class*='fr-icon-']")

    const secondIconClassAttribute = await secondIconSpan.getAttribute("class")
    const secondIconClasses = secondIconClassAttribute?.split(" ") || []
    const secondIconClass = secondIconClasses.find(
      (cls) => cls.startsWith("fr-icon-") && cls !== "fr-icon--sm",
    )

    // Verify there are icons with this class before unchecking
    const secondIconsBefore = page.locator(
      `#addressesPanel [data-controller="pinpoint"] span.${secondIconClass}`,
    )
    expect(await secondIconsBefore.count()).toBeGreaterThan(0)

    // Uncheck the second filter
    await secondCheckboxLabel.click()

    // Wait for loading
    await expect(page.getByTestId("loading-solutions")).toBeVisible()
    await expect(page.getByTestId("loading-solutions")).toBeHidden()

    // Verify the second filter is now unchecked
    await expect(secondFilterCheckbox).not.toBeChecked()

    // Verify icons with the second icon class are now gone
    const secondIconsAfter = page.locator(
      `#addressesPanel [data-controller="pinpoint"] span.${secondIconClass}`,
    )
    expect(await secondIconsAfter.count()).toBe(0)
  })
})

test.describe("ðŸ—ºï¸ Bouton 'Rechercher dans cette zone'", () => {
  test("Le bouton apparaÃ®t aprÃ¨s dÃ©placement de la carte et met Ã  jour les rÃ©sultats", async ({
    page,
  }) => {
    // Navigate to the test preview page that generates the iframe
    await page.goto("/lookbook/preview/tests/t_5_rechercher_dans_zone", {
      waitUntil: "domcontentloaded",
    })

    // Wait for the iframe to be loaded (generated by carte.js)
    const iframe = page.frameLocator("iframe").first()
    await expect(iframe.locator("body")).toBeAttached({ timeout: 10000 })

    // Scroll the iframe into view
    await page.locator("iframe").first().scrollIntoViewIfNeeded()

    // Search for Auray in the iframe
    await searchForAurayInIframe(iframe)

    // Wait for legend to be visible
    await iframe.locator("[data-testid='carte-legend']").waitFor({ timeout: 10000 })

    // Wait for results to be displayed
    await expect(iframe.locator("#addressesPanel")).toBeVisible()

    // Count initial results
    const initialResultsCount = await iframe
      .locator("#addressesPanel [data-controller='pinpoint']")
      .count()
    expect(initialResultsCount).toBeGreaterThan(0)

    // The search in zone button should be hidden initially (no bounding box yet)
    const searchInZoneButton = iframe.getByTestId("searchInZone")
    await expect(searchInZoneButton).toHaveClass(/qf-hidden/)

    // Get the bounding box input (should be empty initially)
    const bboxInput = iframe.locator('[data-search-solution-form-target="bbox"]')
    await expect(bboxInput).toBeAttached()
    const initialBoundingBox = await bboxInput.inputValue()
    expect(initialBoundingBox).toBe("") // Should be empty before map movement

    // Move the map by dragging (simulate user panning the map)
    const mapCanvas = iframe.locator("canvas.maplibregl-canvas")
    await moveMap(page, mapCanvas, 200, 200) // Increase drag distance to trigger map movement

    // Give the map time to process the movement and fire events
    await page.waitForTimeout(500)

    // Wait for the button to appear (it will be shown after map movement is detected)
    await expect(searchInZoneButton).not.toHaveClass(/qf-hidden/, { timeout: 10000 })
    await expect(searchInZoneButton).toBeVisible()

    // Click the button
    await searchInZoneButton.click()

    // Wait for loading to complete
    await expect(iframe.getByTestId("loading-solutions")).toBeVisible()
    await expect(iframe.getByTestId("loading-solutions")).toBeHidden()

    // Verify the bounding box has been set (should now have a value)
    const newBoundingBox = await bboxInput.inputValue()
    expect(newBoundingBox).toBeTruthy()
    expect(newBoundingBox).not.toBe("") // Should now be populated

    // Verify results have changed (count should be different)
    const newResultsCount = await iframe
      .locator("#addressesPanel [data-controller='pinpoint']")
      .count()
    // Results count might be different after searching in new zone
    // We just verify we still have results
    expect(newResultsCount).toBeGreaterThan(0)

    // The button should be hidden again after clicking
    await expect(searchInZoneButton).toHaveClass(/qf-hidden/)
  })
})
